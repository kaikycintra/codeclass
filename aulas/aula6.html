<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aula 6: HTMX e UI</title>
    
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        code {
            padding: 2px 4px;
            border-radius: 4px;
            font-family: monospace;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .note {
            background-color: #e7f5ff;
            border-left: 4px solid #4dabf7;
            padding: 10px;
            margin: 10px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        img {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <h1>Aula 6: HTMX e UI</h1>

    <h2>Introdução</h2>
    <ul>
        <li>Até agora, discutimos como construir páginas web simples usando HTML e CSS. Também começamos a usar Django para criar aplicações web, e aprendemos a usar modelos Django para armazenar informações em nossos sites. Depois introduzimos JavaScript e aprendemos como usá-lo para tornar páginas web mais interativas.</li>
        <li>Hoje, discutiremos paradigmas comuns em design de Interface de Usuário, usando JavaScript e CSS para tornar nossos sites ainda mais amigáveis ao usuário.</li>
    </ul>

    <h2>Interfaces de Usuário</h2>
    <p>Uma Interface de Usuário é como visitantes de uma página web interagem com essa página. Nosso objetivo como desenvolvedores web é tornar essas interações o mais agradáveis possível para o usuário, e há muitos métodos que podemos usar para isso.</p>

    <h2>Single Page Applications (SPAs)</h2>
    <p>Anteriormente, se quiséssemos um site com múltiplas páginas, faríamos isso usando rotas diferentes em nossa aplicação Django. Agora, temos a capacidade de carregar apenas uma única página e então usar JavaScript para manipular a DOM. Uma grande vantagem disso é que só precisamos modificar a parte da página que está realmente mudando. Por exemplo, se temos uma Barra de Navegação que não muda baseada na página atual, não gostaríamos de ter que renderizar novamente essa Barra toda vez que mudamos para uma nova parte da página.</p>
    
    <h3>Requests AJAX</h3>
    <p>Requests AJAX (Asynchronous JavaScript and XML) permitem que páginas web se comuniquem com o servidor de forma assíncrona, ou seja, sem recarregar a página inteira. Isso melhora a experiência do usuário, pois apenas partes específicas da página são atualizadas. AJAX se refere a uma técnica e não uma tecnologia ou ferramenta específica, por isso existem várias formas de realizar esse tipo de request e atualizar o conteúdo da página.</p>
    <p>Abaixo temos um exemplo em que atualizamos nossa página com uma resposta HTML do servidor:</p>
    <pre><code class="language-javascript">document.addEventListener('DOMContentLoaded', function() {
            const button = document.getElementById('fetchHtml');
            const result = document.getElementById('result');
            
            button.addEventListener('click', async function() {
                try {
                    const response = await fetch('/server-endpoint');
                    if (!response.ok) {
                        throw new Error('Erro ao buscar o HTML');
                    }
                    const html = await response.text();
                    result.innerHTML = html; // Insere o HTML retornado no elemento result
                } catch (error) {
                    result.innerHTML = `&lt;p style="color: red;"&gt;${error.message}&lt;/p&gt;`;
                }
            });
        });</code></pre>

    <p>Abaixo temos um exemplo em que atualizamos nossa página com uma resposta JSON do servidor:</p>
    <pre><code class="language-javascript">document.addEventListener('DOMContentLoaded', function() {
            const button = document.getElementById('fetchJson');
            const result = document.getElementById('result');
        
            button.addEventListener('click', async function() {
                try {
                    const response = await fetch('/server-endpoint'); // Substitua pelo endpoint do servidor
                    if (!response.ok) {
                        throw new Error('Erro ao buscar os dados');
                    }
                    const data = await response.json();
                    result.innerHTML = `
                        &lt;h4&gt;${data.title}&lt;/h4&gt;
                        &lt;p&gt;${data.body}&lt;/p&gt;
                    `;
                } catch (error) {
                    result.innerHTML = `&lt;p style="color: red;"&gt;${error.message}&lt;/p&gt;`;
                }
            });
        });</code></pre>
    
    <h2>HTMX</h2>
    <p>HTMX é uma biblioteca que permite acessar recursos modernos dos navegadores diretamente do HTML, em vez de usar JavaScript.</p>

    <p>Para entender o HTMX, primeiro vamos dar uma olhada em uma tag âncora:</p>

    <pre><code class="language-html">&lt;a href="/blog"&gt;Blog&lt;/a&gt;</code></pre>

    <p>Esta tag âncora diz ao navegador:</p>
    <p class="note">"Quando um usuário clicar neste link, faça uma requisição HTTP GET para '/blog' e carregue o conteúdo da resposta na janela do navegador".</p>

    <p>Com isso em mente, considere o seguinte trecho de HTML:</p>

    <pre><code class="language-html">&lt;button hx-post="/clicked"
                hx-trigger="click"
                hx-target="#parent-div"
                hx-swap="outerHTML"&gt;
            Clique Aqui!
&lt;/button&gt;</code></pre>
        
    <p>Isso diz ao HTMX:</p>
    <p class="note">"Quando um usuário clicar neste botão, faça uma requisição HTTP POST para '/clicked' e use o conteúdo da resposta para substituir o elemento com o id parent-div no DOM"</p>

    <p>O HTMX estende e generaliza a ideia central do HTML como hipertexto, abrindo muitas mais possibilidades diretamente na linguagem:</p>

    <ul>
        <li>Agora qualquer elemento, não apenas âncoras e formulários, pode fazer requisições HTTP</li>
        <li>Agora qualquer evento, não apenas cliques ou envios de formulários, pode acionar requisições</li>
        <li>Agora qualquer verbo HTTP, não apenas GET e POST, pode ser usado</li>
        <li>Agora qualquer elemento, não apenas a janela inteira, pode ser o alvo para atualização pela requisição</li>
    </ul>

    <p class="note">Observe que quando você está usando HTMX, no lado do servidor você normalmente responde com HTML, não com JSON.</p>

    <h2>Requests HTMX</h2>
    <p>Podemos trocar somente a parte que nos interessa (como no site do codeclass!) hx-get, hx-target, hx-swap, hx-trigger</p>
    <h2>Scroll</h2>
    <p>hx-trigger load e revealed</p>
    <h3>Scroll Infinito</h3>
    <h2>Busca</h2>
    <p>hx-trigger changed e delay</p>    
    <h2>Carregamento</h2>
    <p>Podemos usar o hx-indicator e o bootstrap placeholder</p>
    <h2>Paginação</h2>
    <p>Mexer no template e botões com hx-get e hx-include</p>
    <h2>Animações</h2>
    <p>Podemos aplicar animações ao selecionar ou apagar um recurso</p>
    
    <!-- Prism.js JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
